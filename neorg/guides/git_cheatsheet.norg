@document.meta
  title: git_cheatsheet
  description:
  authors: ishan
  categories:
  created: 2022-01-14
  version: 0.0.9
@end

*Git cheatsheet*

* *status*
checks for pending changes from your current *branch*
checks for pending changes from other *branches*
 ** *git status*

* *log*
displays the *commits* for the *branch* you currently have checked out
 ** *git log*
  *** displays all the most recent *commits* on your current *branch*
 ** *git log -N*
  *** where N is an integer, displays the N most recent *commits* on your current branch

* *add*
stages any changes undergone by a file or group of files
requires a designated file or group of files in a repository
 ** *git add .*
  *** to add all files not listed in .gitignore
 ** *git add directory/*
  *** to add all files in a directory
 ** *git add filename1 filename2 filename3*
  *** to commit particular files

* *commit*
create a snapshot of your current *branch*
requires a repository which has undergone /staged changes/
a commit can be retrieved or revisited at any time, or given a 'pointer' using *branch*
 ** *git commit*
  *** commits all staged changes
 ** *git commit -m "the commit message that describes any changes"*
  *** commits all staged changes and includes a message
 ** *git commit --amend -m "an amended commit message if the last one contained typos"*
  *** amends the message from the previous commit
 ** *git commit -a*
  *** to add all modified and deleted files to the staging area before comitting

* *branch*
a common misconception is that a branch is a discrete a chain of *commmits*
however a *branch* is simply a pointer to a specific commit that we want to refer back to easily
the *branch* pointer 'moves forward' with each new commit
 ** *git branch*
  *** to list all *branches* on a project
** *git branch new_branch_name*
  *** to make a new *branch*, then git checkout new_branch_name to start playing with it
** *git -m branch_new_name*
  *** to rename your currently checked out *branch*
** *git -m branch_old_name branch_new_name*
  *** to rename a particular *branch* in a project
** *git -d branch_name*
  *** to delete a particular *branch* (will not work if the *branch* has unmerged changes)
** *git -D branch_name*
  *** to delete a particular *branch* regardless of whether it has unmerged changes~
      *warning* don't do this unless you're 100% certain that the *branch* has no changes that you need!!

* *checkout*
tells git which commit or branch to move to
if you checkout at a *branch*/*commit*, you are now 'in' that *branch*/*commit*; anything you do is now being done to that *branch*/*commit*
** *git checkout commit_code*
  *** to move to a particular *commit*
** *git checkout existing_branch_name*
  *** to move to a particular *branch*
** *git checkout -b new_branch_name*
  *** to create a new *branch* and move to it

* *clone*
makes a local copy of a remote repository on your machine
requires the https or ssh of the remote repository
requires a directory to *clone* into (it will appear in your cwd)
** *git clone https[...]github.com*

* *push*
** *git push origin --delete remote_repo_name*
  *** to delete a remote/online *branch*

* *pull*
updates your local repository with any updates from the remote one
can be thought of as a mix of *fetch* and *merge*
requires you to have *cloned* that repository into your machine
requires that repository to be your cwd
requires the name of the remote repository
** *git pull https[...]github.com*

* *fetch*
downloads all changes from remote to local repository
NB this is mostly not needed, as you usually want to *merge* immediately after *fetch*, which can be accomplished as a composite action with *pull*
** *git fetch https[...]github.com*

* *merge*
merges any committed changes from one branch another
it's basically the same as a commit, but instead of committing changes from your current branch to itself, you are committing them from another branch
~ *checkout* the *branch* which we will be *merging* into
    you will potentially get a message like 'your branch is behind 'origin/main' by x commits, and can be fast-forwarded'
~ do a *pull* on the origin
    any changes to your branch will be recorded
~ do a *merge* on your branch to update it and the origin with any new bits from each other
    the two branches are now the same
~ sometimes at this point you will come across a *merge conflict*, in which the actual content of a file in both branches is different
    in this case, simply work through the changes (neovim is good for this) deciding which parts you want from each file in the final merge
** *git merge [branch name]*

* *stash*, *apply*, and *pop*
imagine you worked on a bunch of code only to realise you were on the wrong branch
you can *stash* the changes made to the branch you were on (the 'wrong' one)
and then *apply* or more commonly *pop* the *stash* over to the correct branch (*pop* just means to apply the stashed changes, then remove them)
thus a *stash* basically functions like a temporary commit whose changes you can then shove over to another branch, typically the *stash* is then deleted though you can save it for later
** *git stash*
  *** stores your current staged changes in a *stash*, allowing you to (for instance) cleanly *checkout* another branch without losing changes
** *git stash show*
  *** displays your most recent *stash*
** *git stash list*
  *** displays all stashes and indexes them
** *git stash show@{idx}*
  *** displays the indexed *stash*
** *git apply*
  *** applies your most recent *stash* to your currently checked out branch
** *git pop*
  *** applies your most recent *stash* to your currently checked out branch, and delete the *stash*

* *rebase*
this is kind of like a 'clean *merge*' in that it forces the changes in one *branch* onto another~
but it gives us a cleaner repo history by removing the *branch* history
this is useful in cases where knowledge of the *branch's* existence is not especially useful
it is however less practical for resolving merge conflicts, as mistakes in the merge are harder to undo
** *git rebase target_branch_name*
  *** applies changes from your current *branch* to target_branch_name while also removing history of the current branch
